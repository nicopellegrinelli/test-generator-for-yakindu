/**
 * Generated by itemis CREATE code generator.
 */
package statechart;

import com.yakindu.core.ICycleBased;
import com.yakindu.core.IStatemachine;
import com.yakindu.core.ITimed;
import com.yakindu.core.ITimerService;

public class ArduinoHMISimplified implements ITimed, ICycleBased {

    private static class EvBuf {

        private boolean right;

        private boolean left;

        private boolean up;

        private boolean down;

        private boolean select;
    }

    private static class TimeEventsEvBuf {

        private boolean arduinoHMI_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Start_Timer_time_event_0;
    }

    private static class ArduinoHMIEvBuf {

        private EvBuf iface = new EvBuf();

        private TimeEventsEvBuf timeEvents = new TimeEventsEvBuf();
    }

    public enum State {

        HMI_HANDLE_STATES,
        HMI_HANDLE_STATES_R1_SELECTING,
        HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE,
        HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_TOP,
        HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_MIDDLE,
        HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_LEFT,
        HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_BOTTOM,
        HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_RIGHT,
        HMI_STOPWATCH,
        HMI_STOPWATCH_R1_SELECTING,
        HMI_STOPWATCH_R1_STOPWATCH_ACTIVE,
        HMI_STOPWATCH_R1_STOPWATCH_ACTIVE_STOPWATCH_RESET_TIMER,
        HMI_STOPWATCH_R1_STOPWATCH_ACTIVE_STOPWATCH_START_TIMER,
        HMI_STOPWATCH_R1_STOPWATCH_ACTIVE_STOPWATCH_STOP_TIMER,
        HMI_COUNTER,
        HMI_COUNTER_R1_SELECTING,
        HMI_COUNTER_R1_COUNTER_ACTIVE,
        HMI_COUNTER_R1_COUNTER_ACTIVE_COUNTER_RESET_COUNTER,
        HMI_COUNTER_R1_COUNTER_ACTIVE_COUNTER_COUNT,
        $NULLSTATE$
    }

    private final State[] stateVector = new State[1];

    private ITimerService timerService;

    private final boolean[] timeEvents = new boolean[1];

    private long cnt;

    private long getCnt() {
        return cnt;
    }

    private void setCnt(long value) {
        this.cnt = value;
    }

    private long timeCnt;

    private long getTimeCnt() {
        return timeCnt;
    }

    private void setTimeCnt(long value) {
        this.timeCnt = value;
    }

    private ArduinoHMIEvBuf current = new ArduinoHMIEvBuf();

    private boolean isExecuting;

    private boolean getIsExecuting() {
        return isExecuting;
    }

    private void setIsExecuting(boolean value) {
        this.isExecuting = value;
    }

    public ArduinoHMISimplified() {
        for (int i = 0; i < 1; i++) {
            stateVector[i] = State.$NULLSTATE$;
        }
        clearInEvents();
        /* Default init sequence for statechart ArduinoHMI */
        setCnt(0l);
        setTimeCnt(0l);
        isExecuting = false;
    }

    public void runCycle() {
        /* Performs a 'run to completion' step. */
        if (timerService == null) {
            throw new IllegalStateException("Timer service must be set.");
        }
        if (this.operationCallback == null) {
            throw new IllegalStateException("Operation callback must be set.");
        }
        if (getIsExecuting()) {
            return;
        }
        isExecuting = true;
        swapInEvents();
        microStep();
        isExecuting = false;
    }

    public void enter() {
        /* Activates the state machine. */
        if (timerService == null) {
            throw new IllegalStateException("Timer service must be set.");
        }
        if (this.operationCallback == null) {
            throw new IllegalStateException("Operation callback must be set.");
        }
        if (getIsExecuting()) {
            return;
        }
        isExecuting = true;
        /* Default enter sequence for statechart ArduinoHMI */
        enterSequence_hmi_default();
        isExecuting = false;
    }

    public void exit() {
        /* Deactivates the state machine. */
        if (getIsExecuting()) {
            return;
        }
        isExecuting = true;
        /* Default exit sequence for statechart ArduinoHMI */
        exitSequence_hmi();
        isExecuting = false;
    }

    /**
     * @see IStatemachine#isActive()
     */
    public boolean isActive() {
        return stateVector[0] != State.$NULLSTATE$;
    }

    /**
     * Always returns 'false' since this state machine can never become final.
     *
     * @see IStatemachine#isFinal()
     */
    public boolean isFinal() {
        return false;
    }

    private void swapInEvents() {
        current.iface.right = right;
        right = false;
        current.iface.left = left;
        left = false;
        current.iface.up = up;
        up = false;
        current.iface.down = down;
        down = false;
        current.iface.select = select;
        select = false;
        current.timeEvents.arduinoHMI_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Start_Timer_time_event_0 = timeEvents[0];
        timeEvents[0] = false;
    }

    private void clearInEvents() {
        right = false;
        left = false;
        up = false;
        down = false;
        select = false;
        timeEvents[0] = false;
    }

    private void microStep() {
        switch(stateVector[0]) {
            case HMI_HANDLE_STATES_R1_SELECTING:
                hmi_Handle_States_r1_Selecting_react(-1l);
                break;
            case HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_TOP:
                hmi_Handle_States_r1_Handle_States_Active_handle_states_Top_react(-1l);
                break;
            case HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_MIDDLE:
                hmi_Handle_States_r1_Handle_States_Active_handle_states_Middle_react(-1l);
                break;
            case HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_LEFT:
                hmi_Handle_States_r1_Handle_States_Active_handle_states_Left_react(-1l);
                break;
            case HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_BOTTOM:
                hmi_Handle_States_r1_Handle_States_Active_handle_states_Bottom_react(-1l);
                break;
            case HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_RIGHT:
                hmi_Handle_States_r1_Handle_States_Active_handle_states_Right_react(-1l);
                break;
            case HMI_STOPWATCH_R1_SELECTING:
                hmi_Stopwatch_r1_Selecting_react(-1l);
                break;
            case HMI_STOPWATCH_R1_STOPWATCH_ACTIVE_STOPWATCH_RESET_TIMER:
                hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Reset_Timer_react(-1l);
                break;
            case HMI_STOPWATCH_R1_STOPWATCH_ACTIVE_STOPWATCH_START_TIMER:
                hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Start_Timer_react(-1l);
                break;
            case HMI_STOPWATCH_R1_STOPWATCH_ACTIVE_STOPWATCH_STOP_TIMER:
                hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Stop_Timer_react(-1l);
                break;
            case HMI_COUNTER_R1_SELECTING:
                hmi_Counter_r1_Selecting_react(-1l);
                break;
            case HMI_COUNTER_R1_COUNTER_ACTIVE_COUNTER_RESET_COUNTER:
                hmi_Counter_r1_Counter_Active_counter_Reset_Counter_react(-1l);
                break;
            case HMI_COUNTER_R1_COUNTER_ACTIVE_COUNTER_COUNT:
                hmi_Counter_r1_Counter_Active_counter_Count_react(-1l);
                break;
            default:
                break;
        }
    }

    /**
     * Returns true if the given state is currently active otherwise false.
     */
    public boolean isStateActive(State state) {
        switch(state) {
            case HMI_HANDLE_STATES:
                return stateVector[0].ordinal() >= State.HMI_HANDLE_STATES.ordinal() && stateVector[0].ordinal() <= State.HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_RIGHT.ordinal();
            case HMI_HANDLE_STATES_R1_SELECTING:
                return stateVector[0] == State.HMI_HANDLE_STATES_R1_SELECTING;
            case HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE:
                return stateVector[0].ordinal() >= State.HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE.ordinal() && stateVector[0].ordinal() <= State.HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_RIGHT.ordinal();
            case HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_TOP:
                return stateVector[0] == State.HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_TOP;
            case HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_MIDDLE:
                return stateVector[0] == State.HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_MIDDLE;
            case HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_LEFT:
                return stateVector[0] == State.HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_LEFT;
            case HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_BOTTOM:
                return stateVector[0] == State.HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_BOTTOM;
            case HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_RIGHT:
                return stateVector[0] == State.HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_RIGHT;
            case HMI_STOPWATCH:
                return stateVector[0].ordinal() >= State.HMI_STOPWATCH.ordinal() && stateVector[0].ordinal() <= State.HMI_STOPWATCH_R1_STOPWATCH_ACTIVE_STOPWATCH_STOP_TIMER.ordinal();
            case HMI_STOPWATCH_R1_SELECTING:
                return stateVector[0] == State.HMI_STOPWATCH_R1_SELECTING;
            case HMI_STOPWATCH_R1_STOPWATCH_ACTIVE:
                return stateVector[0].ordinal() >= State.HMI_STOPWATCH_R1_STOPWATCH_ACTIVE.ordinal() && stateVector[0].ordinal() <= State.HMI_STOPWATCH_R1_STOPWATCH_ACTIVE_STOPWATCH_STOP_TIMER.ordinal();
            case HMI_STOPWATCH_R1_STOPWATCH_ACTIVE_STOPWATCH_RESET_TIMER:
                return stateVector[0] == State.HMI_STOPWATCH_R1_STOPWATCH_ACTIVE_STOPWATCH_RESET_TIMER;
            case HMI_STOPWATCH_R1_STOPWATCH_ACTIVE_STOPWATCH_START_TIMER:
                return stateVector[0] == State.HMI_STOPWATCH_R1_STOPWATCH_ACTIVE_STOPWATCH_START_TIMER;
            case HMI_STOPWATCH_R1_STOPWATCH_ACTIVE_STOPWATCH_STOP_TIMER:
                return stateVector[0] == State.HMI_STOPWATCH_R1_STOPWATCH_ACTIVE_STOPWATCH_STOP_TIMER;
            case HMI_COUNTER:
                return stateVector[0].ordinal() >= State.HMI_COUNTER.ordinal() && stateVector[0].ordinal() <= State.HMI_COUNTER_R1_COUNTER_ACTIVE_COUNTER_COUNT.ordinal();
            case HMI_COUNTER_R1_SELECTING:
                return stateVector[0] == State.HMI_COUNTER_R1_SELECTING;
            case HMI_COUNTER_R1_COUNTER_ACTIVE:
                return stateVector[0].ordinal() >= State.HMI_COUNTER_R1_COUNTER_ACTIVE.ordinal() && stateVector[0].ordinal() <= State.HMI_COUNTER_R1_COUNTER_ACTIVE_COUNTER_COUNT.ordinal();
            case HMI_COUNTER_R1_COUNTER_ACTIVE_COUNTER_RESET_COUNTER:
                return stateVector[0] == State.HMI_COUNTER_R1_COUNTER_ACTIVE_COUNTER_RESET_COUNTER;
            case HMI_COUNTER_R1_COUNTER_ACTIVE_COUNTER_COUNT:
                return stateVector[0] == State.HMI_COUNTER_R1_COUNTER_ACTIVE_COUNTER_COUNT;
            default:
                return false;
        }
    }

    public void setTimerService(ITimerService timerService) {
        this.timerService = timerService;
    }

    private ITimerService getTimerService() {
        return timerService;
    }

    public void raiseTimeEvent(int eventID) {
        timeEvents[eventID] = true;
    }

    public interface OperationCallback {

        public void displayLCDString(String value, long length, long position);

        public void displayLCDInteger(long value, long position);

        public void clearLCDRow(long position);
    }

    private OperationCallback operationCallback;

    public void setOperationCallback(OperationCallback operationCallback) {
        this.operationCallback = operationCallback;
    }

    private boolean right;

    public void raiseRight() {
        right = true;
    }

    private boolean left;

    public void raiseLeft() {
        left = true;
    }

    private boolean up;

    public void raiseUp() {
        up = true;
    }

    private boolean down;

    public void raiseDown() {
        down = true;
    }

    private boolean select;

    public void raiseSelect() {
        select = true;
    }

    /* Entry action for state 'Handle States'. */
    private void entryAction_hmi_Handle_States() {
        /* Entry action for state 'Handle States'. */
        operationCallback.displayLCDString("Handle States", 14l, 0l);
    }

    /* Entry action for state 'Top'. */
    private void entryAction_hmi_Handle_States_r1_Handle_States_Active_handle_states_Top() {
        /* Entry action for state 'Top'. */
        operationCallback.displayLCDString("Top", 3l, 1l);
    }

    /* Entry action for state 'Middle'. */
    private void entryAction_hmi_Handle_States_r1_Handle_States_Active_handle_states_Middle() {
        /* Entry action for state 'Middle'. */
        operationCallback.displayLCDString("Middle", 6l, 1l);
    }

    /* Entry action for state 'Left'. */
    private void entryAction_hmi_Handle_States_r1_Handle_States_Active_handle_states_Left() {
        /* Entry action for state 'Left'. */
        operationCallback.displayLCDString("Left", 4l, 1l);
    }

    /* Entry action for state 'Bottom'. */
    private void entryAction_hmi_Handle_States_r1_Handle_States_Active_handle_states_Bottom() {
        /* Entry action for state 'Bottom'. */
        operationCallback.displayLCDString("Bottom", 6l, 1l);
    }

    /* Entry action for state 'Right'. */
    private void entryAction_hmi_Handle_States_r1_Handle_States_Active_handle_states_Right() {
        /* Entry action for state 'Right'. */
        operationCallback.displayLCDString("Right", 5l, 1l);
    }

    /* Entry action for state 'Stopwatch'. */
    private void entryAction_hmi_Stopwatch() {
        /* Entry action for state 'Stopwatch'. */
        operationCallback.displayLCDString("Stopwatch", 9l, 0l);
    }

    /* Entry action for state 'Reset Timer'. */
    private void entryAction_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Reset_Timer() {
        /* Entry action for state 'Reset Timer'. */
        setTimeCnt(0l);
        operationCallback.displayLCDInteger(getTimeCnt(), 1l);
    }

    /* Entry action for state 'Start Timer'. */
    private void entryAction_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Start_Timer() {
        /* Entry action for state 'Start Timer'. */
        timerService.setTimer(this, 0, 100l, false);
        operationCallback.displayLCDInteger(getTimeCnt(), 1l);
    }

    /* Entry action for state 'Stop Timer'. */
    private void entryAction_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Stop_Timer() {
        /* Entry action for state 'Stop Timer'. */
        operationCallback.displayLCDInteger(getTimeCnt(), 1l);
    }

    /* Entry action for state 'Counter'. */
    private void entryAction_hmi_Counter() {
        /* Entry action for state 'Counter'. */
        operationCallback.displayLCDString("Counter", 7l, 0l);
    }

    /* Entry action for state 'Reset Counter'. */
    private void entryAction_hmi_Counter_r1_Counter_Active_counter_Reset_Counter() {
        /* Entry action for state 'Reset Counter'. */
        setCnt(0l);
        operationCallback.displayLCDInteger(getCnt(), 1l);
    }

    /* Entry action for state 'Count'. */
    private void entryAction_hmi_Counter_r1_Counter_Active_counter_Count() {
        /* Entry action for state 'Count'. */
        operationCallback.displayLCDInteger(getCnt(), 1l);
    }

    /* Exit action for state 'Start Timer'. */
    private void exitAction_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Start_Timer() {
        /* Exit action for state 'Start Timer'. */
        timerService.unsetTimer(this, 0);
    }

    /* 'default' enter sequence for state Handle States */
    private void enterSequence_hmi_Handle_States_default() {
        /* 'default' enter sequence for state Handle States */
        entryAction_hmi_Handle_States();
        enterSequence_hmi_Handle_States_r1_default();
    }

    /* 'default' enter sequence for state Selecting */
    private void enterSequence_hmi_Handle_States_r1_Selecting_default() {
        /* 'default' enter sequence for state Selecting */
        stateVector[0] = State.HMI_HANDLE_STATES_R1_SELECTING;
    }

    /* 'default' enter sequence for state Handle States Active */
    private void enterSequence_hmi_Handle_States_r1_Handle_States_Active_default() {
        /* 'default' enter sequence for state Handle States Active */
        enterSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_default();
    }

    /* 'default' enter sequence for state Top */
    private void enterSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Top_default() {
        /* 'default' enter sequence for state Top */
        entryAction_hmi_Handle_States_r1_Handle_States_Active_handle_states_Top();
        stateVector[0] = State.HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_TOP;
    }

    /* 'default' enter sequence for state Middle */
    private void enterSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Middle_default() {
        /* 'default' enter sequence for state Middle */
        entryAction_hmi_Handle_States_r1_Handle_States_Active_handle_states_Middle();
        stateVector[0] = State.HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_MIDDLE;
    }

    /* 'default' enter sequence for state Left */
    private void enterSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Left_default() {
        /* 'default' enter sequence for state Left */
        entryAction_hmi_Handle_States_r1_Handle_States_Active_handle_states_Left();
        stateVector[0] = State.HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_LEFT;
    }

    /* 'default' enter sequence for state Bottom */
    private void enterSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Bottom_default() {
        /* 'default' enter sequence for state Bottom */
        entryAction_hmi_Handle_States_r1_Handle_States_Active_handle_states_Bottom();
        stateVector[0] = State.HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_BOTTOM;
    }

    /* 'default' enter sequence for state Right */
    private void enterSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Right_default() {
        /* 'default' enter sequence for state Right */
        entryAction_hmi_Handle_States_r1_Handle_States_Active_handle_states_Right();
        stateVector[0] = State.HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_RIGHT;
    }

    /* 'default' enter sequence for state Selecting */
    private void enterSequence_hmi_Stopwatch_r1_Selecting_default() {
        /* 'default' enter sequence for state Selecting */
        stateVector[0] = State.HMI_STOPWATCH_R1_SELECTING;
    }

    /* 'default' enter sequence for state Stopwatch Active */
    private void enterSequence_hmi_Stopwatch_r1_Stopwatch_Active_default() {
        /* 'default' enter sequence for state Stopwatch Active */
        enterSequence_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_default();
    }

    /* 'default' enter sequence for state Reset Timer */
    private void enterSequence_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Reset_Timer_default() {
        /* 'default' enter sequence for state Reset Timer */
        entryAction_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Reset_Timer();
        stateVector[0] = State.HMI_STOPWATCH_R1_STOPWATCH_ACTIVE_STOPWATCH_RESET_TIMER;
    }

    /* 'default' enter sequence for state Start Timer */
    private void enterSequence_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Start_Timer_default() {
        /* 'default' enter sequence for state Start Timer */
        entryAction_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Start_Timer();
        stateVector[0] = State.HMI_STOPWATCH_R1_STOPWATCH_ACTIVE_STOPWATCH_START_TIMER;
    }

    /* 'default' enter sequence for state Stop Timer */
    private void enterSequence_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Stop_Timer_default() {
        /* 'default' enter sequence for state Stop Timer */
        entryAction_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Stop_Timer();
        stateVector[0] = State.HMI_STOPWATCH_R1_STOPWATCH_ACTIVE_STOPWATCH_STOP_TIMER;
    }

    /* 'default' enter sequence for state Selecting */
    private void enterSequence_hmi_Counter_r1_Selecting_default() {
        /* 'default' enter sequence for state Selecting */
        stateVector[0] = State.HMI_COUNTER_R1_SELECTING;
    }

    /* 'default' enter sequence for state Counter Active */
    private void enterSequence_hmi_Counter_r1_Counter_Active_default() {
        /* 'default' enter sequence for state Counter Active */
        enterSequence_hmi_Counter_r1_Counter_Active_counter_default();
    }

    /* 'default' enter sequence for state Reset Counter */
    private void enterSequence_hmi_Counter_r1_Counter_Active_counter_Reset_Counter_default() {
        /* 'default' enter sequence for state Reset Counter */
        entryAction_hmi_Counter_r1_Counter_Active_counter_Reset_Counter();
        stateVector[0] = State.HMI_COUNTER_R1_COUNTER_ACTIVE_COUNTER_RESET_COUNTER;
    }

    /* 'default' enter sequence for state Count */
    private void enterSequence_hmi_Counter_r1_Counter_Active_counter_Count_default() {
        /* 'default' enter sequence for state Count */
        entryAction_hmi_Counter_r1_Counter_Active_counter_Count();
        stateVector[0] = State.HMI_COUNTER_R1_COUNTER_ACTIVE_COUNTER_COUNT;
    }

    /* 'default' enter sequence for region hmi */
    private void enterSequence_hmi_default() {
        /* 'default' enter sequence for region hmi */
        react_hmi__entry_Default();
    }

    /* 'default' enter sequence for region r1 */
    private void enterSequence_hmi_Handle_States_r1_default() {
        /* 'default' enter sequence for region r1 */
        react_hmi_Handle_States_r1__entry_Default();
    }

    /* 'default' enter sequence for region handle states */
    private void enterSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_default() {
        /* 'default' enter sequence for region handle states */
        react_hmi_Handle_States_r1_Handle_States_Active_handle_states__entry_Default();
    }

    /* 'default' enter sequence for region stopwatch */
    private void enterSequence_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_default() {
        /* 'default' enter sequence for region stopwatch */
        react_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch__entry_Default();
    }

    /* 'default' enter sequence for region counter */
    private void enterSequence_hmi_Counter_r1_Counter_Active_counter_default() {
        /* 'default' enter sequence for region counter */
        react_hmi_Counter_r1_Counter_Active_counter__entry_Default();
    }

    /* Default exit sequence for state Handle States */
    private void exitSequence_hmi_Handle_States() {
        /* Default exit sequence for state Handle States */
        exitSequence_hmi_Handle_States_r1();
    }

    /* Default exit sequence for state Selecting */
    private void exitSequence_hmi_Handle_States_r1_Selecting() {
        /* Default exit sequence for state Selecting */
        stateVector[0] = State.$NULLSTATE$;
    }

    /* Default exit sequence for state Handle States Active */
    private void exitSequence_hmi_Handle_States_r1_Handle_States_Active() {
        /* Default exit sequence for state Handle States Active */
        exitSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states();
    }

    /* Default exit sequence for state Top */
    private void exitSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Top() {
        /* Default exit sequence for state Top */
        stateVector[0] = State.$NULLSTATE$;
    }

    /* Default exit sequence for state Middle */
    private void exitSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Middle() {
        /* Default exit sequence for state Middle */
        stateVector[0] = State.$NULLSTATE$;
    }

    /* Default exit sequence for state Left */
    private void exitSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Left() {
        /* Default exit sequence for state Left */
        stateVector[0] = State.$NULLSTATE$;
    }

    /* Default exit sequence for state Bottom */
    private void exitSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Bottom() {
        /* Default exit sequence for state Bottom */
        stateVector[0] = State.$NULLSTATE$;
    }

    /* Default exit sequence for state Right */
    private void exitSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Right() {
        /* Default exit sequence for state Right */
        stateVector[0] = State.$NULLSTATE$;
    }

    /* Default exit sequence for state Stopwatch */
    private void exitSequence_hmi_Stopwatch() {
        /* Default exit sequence for state Stopwatch */
        exitSequence_hmi_Stopwatch_r1();
    }

    /* Default exit sequence for state Selecting */
    private void exitSequence_hmi_Stopwatch_r1_Selecting() {
        /* Default exit sequence for state Selecting */
        stateVector[0] = State.$NULLSTATE$;
    }

    /* Default exit sequence for state Stopwatch Active */
    private void exitSequence_hmi_Stopwatch_r1_Stopwatch_Active() {
        /* Default exit sequence for state Stopwatch Active */
        exitSequence_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch();
    }

    /* Default exit sequence for state Reset Timer */
    private void exitSequence_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Reset_Timer() {
        /* Default exit sequence for state Reset Timer */
        stateVector[0] = State.$NULLSTATE$;
    }

    /* Default exit sequence for state Start Timer */
    private void exitSequence_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Start_Timer() {
        /* Default exit sequence for state Start Timer */
        stateVector[0] = State.$NULLSTATE$;
        exitAction_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Start_Timer();
    }

    /* Default exit sequence for state Stop Timer */
    private void exitSequence_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Stop_Timer() {
        /* Default exit sequence for state Stop Timer */
        stateVector[0] = State.$NULLSTATE$;
    }

    /* Default exit sequence for state Counter */
    private void exitSequence_hmi_Counter() {
        /* Default exit sequence for state Counter */
        exitSequence_hmi_Counter_r1();
    }

    /* Default exit sequence for state Selecting */
    private void exitSequence_hmi_Counter_r1_Selecting() {
        /* Default exit sequence for state Selecting */
        stateVector[0] = State.$NULLSTATE$;
    }

    /* Default exit sequence for state Counter Active */
    private void exitSequence_hmi_Counter_r1_Counter_Active() {
        /* Default exit sequence for state Counter Active */
        exitSequence_hmi_Counter_r1_Counter_Active_counter();
    }

    /* Default exit sequence for state Reset Counter */
    private void exitSequence_hmi_Counter_r1_Counter_Active_counter_Reset_Counter() {
        /* Default exit sequence for state Reset Counter */
        stateVector[0] = State.$NULLSTATE$;
    }

    /* Default exit sequence for state Count */
    private void exitSequence_hmi_Counter_r1_Counter_Active_counter_Count() {
        /* Default exit sequence for state Count */
        stateVector[0] = State.$NULLSTATE$;
    }

    /* Default exit sequence for region hmi */
    private void exitSequence_hmi() {
        /* Default exit sequence for region hmi */
        switch(stateVector[0]) {
            case HMI_HANDLE_STATES_R1_SELECTING:
                exitSequence_hmi_Handle_States_r1_Selecting();
                break;
            case HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_TOP:
                exitSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Top();
                break;
            case HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_MIDDLE:
                exitSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Middle();
                break;
            case HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_LEFT:
                exitSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Left();
                break;
            case HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_BOTTOM:
                exitSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Bottom();
                break;
            case HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_RIGHT:
                exitSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Right();
                break;
            case HMI_STOPWATCH_R1_SELECTING:
                exitSequence_hmi_Stopwatch_r1_Selecting();
                break;
            case HMI_STOPWATCH_R1_STOPWATCH_ACTIVE_STOPWATCH_RESET_TIMER:
                exitSequence_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Reset_Timer();
                break;
            case HMI_STOPWATCH_R1_STOPWATCH_ACTIVE_STOPWATCH_START_TIMER:
                exitSequence_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Start_Timer();
                break;
            case HMI_STOPWATCH_R1_STOPWATCH_ACTIVE_STOPWATCH_STOP_TIMER:
                exitSequence_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Stop_Timer();
                break;
            case HMI_COUNTER_R1_SELECTING:
                exitSequence_hmi_Counter_r1_Selecting();
                break;
            case HMI_COUNTER_R1_COUNTER_ACTIVE_COUNTER_RESET_COUNTER:
                exitSequence_hmi_Counter_r1_Counter_Active_counter_Reset_Counter();
                break;
            case HMI_COUNTER_R1_COUNTER_ACTIVE_COUNTER_COUNT:
                exitSequence_hmi_Counter_r1_Counter_Active_counter_Count();
                break;
            default:
                break;
        }
    }

    /* Default exit sequence for region r1 */
    private void exitSequence_hmi_Handle_States_r1() {
        /* Default exit sequence for region r1 */
        switch(stateVector[0]) {
            case HMI_HANDLE_STATES_R1_SELECTING:
                exitSequence_hmi_Handle_States_r1_Selecting();
                break;
            case HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_TOP:
                exitSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Top();
                break;
            case HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_MIDDLE:
                exitSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Middle();
                break;
            case HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_LEFT:
                exitSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Left();
                break;
            case HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_BOTTOM:
                exitSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Bottom();
                break;
            case HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_RIGHT:
                exitSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Right();
                break;
            default:
                break;
        }
    }

    /* Default exit sequence for region handle states */
    private void exitSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states() {
        /* Default exit sequence for region handle states */
        switch(stateVector[0]) {
            case HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_TOP:
                exitSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Top();
                break;
            case HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_MIDDLE:
                exitSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Middle();
                break;
            case HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_LEFT:
                exitSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Left();
                break;
            case HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_BOTTOM:
                exitSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Bottom();
                break;
            case HMI_HANDLE_STATES_R1_HANDLE_STATES_ACTIVE_HANDLE_STATES_RIGHT:
                exitSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Right();
                break;
            default:
                break;
        }
    }

    /* Default exit sequence for region r1 */
    private void exitSequence_hmi_Stopwatch_r1() {
        /* Default exit sequence for region r1 */
        switch(stateVector[0]) {
            case HMI_STOPWATCH_R1_SELECTING:
                exitSequence_hmi_Stopwatch_r1_Selecting();
                break;
            case HMI_STOPWATCH_R1_STOPWATCH_ACTIVE_STOPWATCH_RESET_TIMER:
                exitSequence_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Reset_Timer();
                break;
            case HMI_STOPWATCH_R1_STOPWATCH_ACTIVE_STOPWATCH_START_TIMER:
                exitSequence_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Start_Timer();
                break;
            case HMI_STOPWATCH_R1_STOPWATCH_ACTIVE_STOPWATCH_STOP_TIMER:
                exitSequence_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Stop_Timer();
                break;
            default:
                break;
        }
    }

    /* Default exit sequence for region stopwatch */
    private void exitSequence_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch() {
        /* Default exit sequence for region stopwatch */
        switch(stateVector[0]) {
            case HMI_STOPWATCH_R1_STOPWATCH_ACTIVE_STOPWATCH_RESET_TIMER:
                exitSequence_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Reset_Timer();
                break;
            case HMI_STOPWATCH_R1_STOPWATCH_ACTIVE_STOPWATCH_START_TIMER:
                exitSequence_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Start_Timer();
                break;
            case HMI_STOPWATCH_R1_STOPWATCH_ACTIVE_STOPWATCH_STOP_TIMER:
                exitSequence_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Stop_Timer();
                break;
            default:
                break;
        }
    }

    /* Default exit sequence for region r1 */
    private void exitSequence_hmi_Counter_r1() {
        /* Default exit sequence for region r1 */
        switch(stateVector[0]) {
            case HMI_COUNTER_R1_SELECTING:
                exitSequence_hmi_Counter_r1_Selecting();
                break;
            case HMI_COUNTER_R1_COUNTER_ACTIVE_COUNTER_RESET_COUNTER:
                exitSequence_hmi_Counter_r1_Counter_Active_counter_Reset_Counter();
                break;
            case HMI_COUNTER_R1_COUNTER_ACTIVE_COUNTER_COUNT:
                exitSequence_hmi_Counter_r1_Counter_Active_counter_Count();
                break;
            default:
                break;
        }
    }

    /* Default exit sequence for region counter */
    private void exitSequence_hmi_Counter_r1_Counter_Active_counter() {
        /* Default exit sequence for region counter */
        switch(stateVector[0]) {
            case HMI_COUNTER_R1_COUNTER_ACTIVE_COUNTER_RESET_COUNTER:
                exitSequence_hmi_Counter_r1_Counter_Active_counter_Reset_Counter();
                break;
            case HMI_COUNTER_R1_COUNTER_ACTIVE_COUNTER_COUNT:
                exitSequence_hmi_Counter_r1_Counter_Active_counter_Count();
                break;
            default:
                break;
        }
    }

    /* Default react sequence for initial entry  */
    private void react_hmi__entry_Default() {
        /* Default react sequence for initial entry  */
        enterSequence_hmi_Handle_States_default();
    }

    /* Default react sequence for initial entry  */
    private void react_hmi_Handle_States_r1__entry_Default() {
        /* Default react sequence for initial entry  */
        enterSequence_hmi_Handle_States_r1_Selecting_default();
    }

    /* Default react sequence for initial entry  */
    private void react_hmi_Handle_States_r1_Handle_States_Active_handle_states__entry_Default() {
        /* Default react sequence for initial entry  */
        enterSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Top_default();
    }

    /* Default react sequence for initial entry  */
    private void react_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch__entry_Default() {
        /* Default react sequence for initial entry  */
        enterSequence_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Reset_Timer_default();
    }

    /* Default react sequence for initial entry  */
    private void react_hmi_Counter_r1_Counter_Active_counter__entry_Default() {
        /* Default react sequence for initial entry  */
        enterSequence_hmi_Counter_r1_Counter_Active_counter_Reset_Counter_default();
    }

    private long react(long transitioned_before) {
        /* State machine reactions. */
        return transitioned_before;
    }

    private long hmi_Handle_States_react(long transitioned_before) {
        /* The reactions of state Handle States. */
        long transitioned_after = transitioned_before;
        /* Always execute local reactions. */
        transitioned_after = react(transitioned_before);
        return transitioned_after;
    }

    private long hmi_Handle_States_r1_Selecting_react(long transitioned_before) {
        /* The reactions of state Selecting. */
        long transitioned_after = transitioned_before;
        if (transitioned_after < 0l) {
            if (current.iface.select) {
                exitSequence_hmi_Handle_States_r1_Selecting();
                enterSequence_hmi_Handle_States_r1_Handle_States_Active_default();
                hmi_Handle_States_react(0l);
                transitioned_after = 0l;
            } else {
                if (current.iface.right) {
                    exitSequence_hmi_Handle_States();
                    entryAction_hmi_Stopwatch();
                    enterSequence_hmi_Stopwatch_r1_Selecting_default();
                    react(0l);
                    transitioned_after = 0l;
                }
            }
        }
        /* If no transition was taken */
        if (transitioned_after == transitioned_before) {
            /* then execute local reactions. */
            transitioned_after = hmi_Handle_States_react(transitioned_before);
        }
        return transitioned_after;
    }

    private long hmi_Handle_States_r1_Handle_States_Active_react(long transitioned_before) {
        /* The reactions of state Handle States Active. */
        long transitioned_after = transitioned_before;
        if (transitioned_after < 0l) {
            if (current.iface.select) {
                exitSequence_hmi_Handle_States_r1_Handle_States_Active();
                operationCallback.clearLCDRow(1l);
                enterSequence_hmi_Handle_States_r1_Selecting_default();
                hmi_Handle_States_react(0l);
                transitioned_after = 0l;
            }
        }
        /* If no transition was taken */
        if (transitioned_after == transitioned_before) {
            /* then execute local reactions. */
            transitioned_after = hmi_Handle_States_react(transitioned_before);
        }
        return transitioned_after;
    }

    private long hmi_Handle_States_r1_Handle_States_Active_handle_states_Top_react(long transitioned_before) {
        /* The reactions of state Top. */
        long transitioned_after = transitioned_before;
        if (transitioned_after < 0l) {
            if (current.iface.down) {
                exitSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Top();
                enterSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Middle_default();
                hmi_Handle_States_r1_Handle_States_Active_react(0l);
                transitioned_after = 0l;
            }
        }
        /* If no transition was taken */
        if (transitioned_after == transitioned_before) {
            /* then execute local reactions. */
            transitioned_after = hmi_Handle_States_r1_Handle_States_Active_react(transitioned_before);
        }
        return transitioned_after;
    }

    private long hmi_Handle_States_r1_Handle_States_Active_handle_states_Middle_react(long transitioned_before) {
        /* The reactions of state Middle. */
        long transitioned_after = transitioned_before;
        if (transitioned_after < 0l) {
            if (current.iface.right) {
                exitSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Middle();
                enterSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Right_default();
                hmi_Handle_States_r1_Handle_States_Active_react(0l);
                transitioned_after = 0l;
            } else {
                if (current.iface.down) {
                    exitSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Middle();
                    enterSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Bottom_default();
                    hmi_Handle_States_r1_Handle_States_Active_react(0l);
                    transitioned_after = 0l;
                } else {
                    if (current.iface.left) {
                        exitSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Middle();
                        enterSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Left_default();
                        hmi_Handle_States_r1_Handle_States_Active_react(0l);
                        transitioned_after = 0l;
                    } else {
                        if (current.iface.up) {
                            exitSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Middle();
                            enterSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Top_default();
                            hmi_Handle_States_r1_Handle_States_Active_react(0l);
                            transitioned_after = 0l;
                        }
                    }
                }
            }
        }
        /* If no transition was taken */
        if (transitioned_after == transitioned_before) {
            /* then execute local reactions. */
            transitioned_after = hmi_Handle_States_r1_Handle_States_Active_react(transitioned_before);
        }
        return transitioned_after;
    }

    private long hmi_Handle_States_r1_Handle_States_Active_handle_states_Left_react(long transitioned_before) {
        /* The reactions of state Left. */
        long transitioned_after = transitioned_before;
        if (transitioned_after < 0l) {
            if (current.iface.right) {
                exitSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Left();
                enterSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Middle_default();
                hmi_Handle_States_r1_Handle_States_Active_react(0l);
                transitioned_after = 0l;
            }
        }
        /* If no transition was taken */
        if (transitioned_after == transitioned_before) {
            /* then execute local reactions. */
            transitioned_after = hmi_Handle_States_r1_Handle_States_Active_react(transitioned_before);
        }
        return transitioned_after;
    }

    private long hmi_Handle_States_r1_Handle_States_Active_handle_states_Bottom_react(long transitioned_before) {
        /* The reactions of state Bottom. */
        long transitioned_after = transitioned_before;
        if (transitioned_after < 0l) {
            if (current.iface.up) {
                exitSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Bottom();
                enterSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Middle_default();
                hmi_Handle_States_r1_Handle_States_Active_react(0l);
                transitioned_after = 0l;
            }
        }
        /* If no transition was taken */
        if (transitioned_after == transitioned_before) {
            /* then execute local reactions. */
            transitioned_after = hmi_Handle_States_r1_Handle_States_Active_react(transitioned_before);
        }
        return transitioned_after;
    }

    private long hmi_Handle_States_r1_Handle_States_Active_handle_states_Right_react(long transitioned_before) {
        /* The reactions of state Right. */
        long transitioned_after = transitioned_before;
        if (transitioned_after < 0l) {
            if (current.iface.left) {
                exitSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Right();
                enterSequence_hmi_Handle_States_r1_Handle_States_Active_handle_states_Middle_default();
                hmi_Handle_States_r1_Handle_States_Active_react(0l);
                transitioned_after = 0l;
            }
        }
        /* If no transition was taken */
        if (transitioned_after == transitioned_before) {
            /* then execute local reactions. */
            transitioned_after = hmi_Handle_States_r1_Handle_States_Active_react(transitioned_before);
        }
        return transitioned_after;
    }

    private long hmi_Stopwatch_react(long transitioned_before) {
        /* The reactions of state Stopwatch. */
        long transitioned_after = transitioned_before;
        /* Always execute local reactions. */
        transitioned_after = react(transitioned_before);
        return transitioned_after;
    }

    private long hmi_Stopwatch_r1_Selecting_react(long transitioned_before) {
        /* The reactions of state Selecting. */
        long transitioned_after = transitioned_before;
        if (transitioned_after < 0l) {
            if (current.iface.left) {
                exitSequence_hmi_Stopwatch();
                entryAction_hmi_Handle_States();
                enterSequence_hmi_Handle_States_r1_Selecting_default();
                react(0l);
                transitioned_after = 0l;
            } else {
                if (current.iface.select) {
                    exitSequence_hmi_Stopwatch_r1_Selecting();
                    enterSequence_hmi_Stopwatch_r1_Stopwatch_Active_default();
                    hmi_Stopwatch_react(0l);
                    transitioned_after = 0l;
                } else {
                    if (current.iface.right) {
                        exitSequence_hmi_Stopwatch();
                        entryAction_hmi_Counter();
                        enterSequence_hmi_Counter_r1_Selecting_default();
                        react(0l);
                        transitioned_after = 0l;
                    }
                }
            }
        }
        /* If no transition was taken */
        if (transitioned_after == transitioned_before) {
            /* then execute local reactions. */
            transitioned_after = hmi_Stopwatch_react(transitioned_before);
        }
        return transitioned_after;
    }

    private long hmi_Stopwatch_r1_Stopwatch_Active_react(long transitioned_before) {
        /* The reactions of state Stopwatch Active. */
        long transitioned_after = transitioned_before;
        if (transitioned_after < 0l) {
            if (current.iface.select) {
                exitSequence_hmi_Stopwatch_r1_Stopwatch_Active();
                operationCallback.clearLCDRow(1l);
                enterSequence_hmi_Stopwatch_r1_Selecting_default();
                hmi_Stopwatch_react(0l);
                transitioned_after = 0l;
            }
        }
        /* If no transition was taken */
        if (transitioned_after == transitioned_before) {
            /* then execute local reactions. */
            transitioned_after = hmi_Stopwatch_react(transitioned_before);
        }
        return transitioned_after;
    }

    private long hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Reset_Timer_react(long transitioned_before) {
        /* The reactions of state Reset Timer. */
        long transitioned_after = transitioned_before;
        if (transitioned_after < 0l) {
            if (current.iface.left) {
                exitSequence_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Reset_Timer();
                enterSequence_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Start_Timer_default();
                hmi_Stopwatch_r1_Stopwatch_Active_react(0l);
                transitioned_after = 0l;
            }
        }
        /* If no transition was taken */
        if (transitioned_after == transitioned_before) {
            /* then execute local reactions. */
            transitioned_after = hmi_Stopwatch_r1_Stopwatch_Active_react(transitioned_before);
        }
        return transitioned_after;
    }

    private long hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Start_Timer_react(long transitioned_before) {
        /* The reactions of state Start Timer. */
        long transitioned_after = transitioned_before;
        if (transitioned_after < 0l) {
            if (current.iface.right) {
                exitSequence_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Start_Timer();
                enterSequence_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Stop_Timer_default();
                hmi_Stopwatch_r1_Stopwatch_Active_react(0l);
                transitioned_after = 0l;
            } else {
                if (current.timeEvents.arduinoHMI_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Start_Timer_time_event_0) {
                    exitSequence_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Start_Timer();
                    setTimeCnt((timeCnt + 100l));
                    current.timeEvents.arduinoHMI_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Start_Timer_time_event_0 = false;
                    enterSequence_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Start_Timer_default();
                    hmi_Stopwatch_r1_Stopwatch_Active_react(0l);
                    transitioned_after = 0l;
                }
            }
        }
        /* If no transition was taken */
        if (transitioned_after == transitioned_before) {
            /* then execute local reactions. */
            transitioned_after = hmi_Stopwatch_r1_Stopwatch_Active_react(transitioned_before);
        }
        return transitioned_after;
    }

    private long hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Stop_Timer_react(long transitioned_before) {
        /* The reactions of state Stop Timer. */
        long transitioned_after = transitioned_before;
        if (transitioned_after < 0l) {
            if (current.iface.left) {
                exitSequence_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Stop_Timer();
                enterSequence_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Start_Timer_default();
                hmi_Stopwatch_r1_Stopwatch_Active_react(0l);
                transitioned_after = 0l;
            } else {
                if ((current.iface.up || current.iface.down)) {
                    exitSequence_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Stop_Timer();
                    operationCallback.clearLCDRow(1l);
                    enterSequence_hmi_Stopwatch_r1_Stopwatch_Active_stopwatch_Reset_Timer_default();
                    hmi_Stopwatch_r1_Stopwatch_Active_react(0l);
                    transitioned_after = 0l;
                }
            }
        }
        /* If no transition was taken */
        if (transitioned_after == transitioned_before) {
            /* then execute local reactions. */
            transitioned_after = hmi_Stopwatch_r1_Stopwatch_Active_react(transitioned_before);
        }
        return transitioned_after;
    }

    private long hmi_Counter_react(long transitioned_before) {
        /* The reactions of state Counter. */
        long transitioned_after = transitioned_before;
        /* Always execute local reactions. */
        transitioned_after = react(transitioned_before);
        return transitioned_after;
    }

    private long hmi_Counter_r1_Selecting_react(long transitioned_before) {
        /* The reactions of state Selecting. */
        long transitioned_after = transitioned_before;
        if (transitioned_after < 0l) {
            if (current.iface.select) {
                exitSequence_hmi_Counter_r1_Selecting();
                enterSequence_hmi_Counter_r1_Counter_Active_default();
                hmi_Counter_react(0l);
                transitioned_after = 0l;
            } else {
                if (current.iface.left) {
                    exitSequence_hmi_Counter();
                    entryAction_hmi_Stopwatch();
                    enterSequence_hmi_Stopwatch_r1_Selecting_default();
                    react(0l);
                    transitioned_after = 0l;
                }
            }
        }
        /* If no transition was taken */
        if (transitioned_after == transitioned_before) {
            /* then execute local reactions. */
            transitioned_after = hmi_Counter_react(transitioned_before);
        }
        return transitioned_after;
    }

    private long hmi_Counter_r1_Counter_Active_react(long transitioned_before) {
        /* The reactions of state Counter Active. */
        long transitioned_after = transitioned_before;
        if (transitioned_after < 0l) {
            if (current.iface.select) {
                exitSequence_hmi_Counter_r1_Counter_Active();
                operationCallback.clearLCDRow(1l);
                enterSequence_hmi_Counter_r1_Selecting_default();
                hmi_Counter_react(0l);
                transitioned_after = 0l;
            }
        }
        /* If no transition was taken */
        if (transitioned_after == transitioned_before) {
            /* then execute local reactions. */
            transitioned_after = hmi_Counter_react(transitioned_before);
        }
        return transitioned_after;
    }

    private long hmi_Counter_r1_Counter_Active_counter_Reset_Counter_react(long transitioned_before) {
        /* The reactions of state Reset Counter. */
        long transitioned_after = transitioned_before;
        if (transitioned_after < 0l) {
            if ((current.iface.left || (current.iface.right || (current.iface.up || current.iface.down)))) {
                exitSequence_hmi_Counter_r1_Counter_Active_counter_Reset_Counter();
                enterSequence_hmi_Counter_r1_Counter_Active_counter_Count_default();
                hmi_Counter_r1_Counter_Active_react(0l);
                transitioned_after = 0l;
            }
        }
        /* If no transition was taken */
        if (transitioned_after == transitioned_before) {
            /* then execute local reactions. */
            transitioned_after = hmi_Counter_r1_Counter_Active_react(transitioned_before);
        }
        return transitioned_after;
    }

    private long hmi_Counter_r1_Counter_Active_counter_Count_react(long transitioned_before) {
        /* The reactions of state Count. */
        long transitioned_after = transitioned_before;
        if (transitioned_after < 0l) {
            if (current.iface.up) {
                exitSequence_hmi_Counter_r1_Counter_Active_counter_Count();
                setCnt((cnt + 1l));
                enterSequence_hmi_Counter_r1_Counter_Active_counter_Count_default();
                hmi_Counter_r1_Counter_Active_react(0l);
                transitioned_after = 0l;
            } else {
                if (((current.iface.down) && (getCnt() > 0l))) {
                    exitSequence_hmi_Counter_r1_Counter_Active_counter_Count();
                    setCnt((cnt - 1l));
                    enterSequence_hmi_Counter_r1_Counter_Active_counter_Count_default();
                    hmi_Counter_r1_Counter_Active_react(0l);
                    transitioned_after = 0l;
                } else {
                    if ((current.iface.left || current.iface.right)) {
                        exitSequence_hmi_Counter_r1_Counter_Active_counter_Count();
                        enterSequence_hmi_Counter_r1_Counter_Active_counter_Reset_Counter_default();
                        hmi_Counter_r1_Counter_Active_react(0l);
                        transitioned_after = 0l;
                    }
                }
            }
        }
        /* If no transition was taken */
        if (transitioned_after == transitioned_before) {
            /* then execute local reactions. */
            transitioned_after = hmi_Counter_r1_Counter_Active_react(transitioned_before);
        }
        return transitioned_after;
    }
}
