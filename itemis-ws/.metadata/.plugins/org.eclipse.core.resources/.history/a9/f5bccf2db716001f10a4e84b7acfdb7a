/**
 * Generated by itemis CREATE code generator.
 */
package statechart;

import com.yakindu.core.ICycleBased;
import com.yakindu.core.IStatemachine;
import com.yakindu.core.ITimed;
import com.yakindu.core.ITimerService;
import com.yakindu.core.rx.Observable;

public class ___TrafficLightSimplified implements ITimed, ICycleBased {

    public static class Lights {

        private boolean red;

        private boolean getRed() {
            return red;
        }

        private void setRed(boolean value) {
            this.red = value;
        }

        private boolean yellow;

        private boolean getYellow() {
            return yellow;
        }

        private void setYellow(boolean value) {
            this.yellow = value;
        }

        private boolean green;

        private boolean getGreen() {
            return green;
        }

        private void setGreen(boolean value) {
            this.green = value;
        }
    }

    public static class Config {

        private long releasePeriod;

        private long getReleasePeriod() {
            return releasePeriod;
        }

        private void setReleasePeriod(long value) {
            this.releasePeriod = value;
        }

        private long preparePeriod;

        private long getPreparePeriod() {
            return preparePeriod;
        }

        private void setPreparePeriod(long value) {
            this.preparePeriod = value;
        }
    }

    private static class EvBuf {

        private boolean switchOn;

        private boolean switchOff;

        private boolean attention;

        private boolean block;

        private boolean release;
    }

    private static class TimeEventsEvBuf {

        private boolean ___TrafficLight_main_On_main_Released_time_event_0;

        private boolean ___TrafficLight_main_On_main_Attention_time_event_0;

        private boolean ___TrafficLight_main_On_main_PrepareBlock_time_event_0;
    }

    private static class ___TrafficLightEvBuf {

        private EvBuf iface = new EvBuf();

        private TimeEventsEvBuf timeEvents = new TimeEventsEvBuf();
    }

    private Lights lights;

    private Config config;

    public enum State {

        MAIN_OFF,
        MAIN_ON,
        MAIN_ON_MAIN_BLOCKED,
        MAIN_ON_MAIN_RELEASED,
        MAIN_ON_MAIN_ATTENTION,
        MAIN_ON_MAIN_PREPAREBLOCK,
        $NULLSTATE$
    }

    private final State[] stateVector = new State[1];

    private ITimerService timerService;

    private final boolean[] timeEvents = new boolean[3];

    static final private boolean oN = true;

    private boolean getON() {
        return oN;
    }

    static final private boolean oFF = false;

    private boolean getOFF() {
        return oFF;
    }

    private ___TrafficLightEvBuf current = new ___TrafficLightEvBuf();

    private boolean isExecuting;

    private boolean getIsExecuting() {
        return isExecuting;
    }

    private void setIsExecuting(boolean value) {
        this.isExecuting = value;
    }

    public ___TrafficLightSimplified() {
        lights = new Lights();
        config = new Config();
        for (int i = 0; i < 1; i++) {
            stateVector[i] = State.$NULLSTATE$;
        }
        clearInEvents();
        /* Default init sequence for statechart ___TrafficLight */
        lights.setRed(false);
        lights.setYellow(false);
        lights.setGreen(false);
        config.setReleasePeriod(6l);
        config.setPreparePeriod(2l);
        isExecuting = false;
    }

    public void runCycle() {
        /* Performs a 'run to completion' step. */
        if (timerService == null) {
            throw new IllegalStateException("Timer service must be set.");
        }
        if (getIsExecuting()) {
            return;
        }
        isExecuting = true;
        swapInEvents();
        microStep();
        isExecuting = false;
    }

    public void enter() {
        /* Activates the state machine. */
        if (timerService == null) {
            throw new IllegalStateException("Timer service must be set.");
        }
        if (getIsExecuting()) {
            return;
        }
        isExecuting = true;
        /* Default enter sequence for statechart ___TrafficLight */
        enterSequence_main_default();
        isExecuting = false;
    }

    public void exit() {
        /* Deactivates the state machine. */
        if (getIsExecuting()) {
            return;
        }
        isExecuting = true;
        /* Default exit sequence for statechart ___TrafficLight */
        exitSequence_main();
        isExecuting = false;
    }

    /**
     * @see IStatemachine#isActive()
     */
    public boolean isActive() {
        return stateVector[0] != State.$NULLSTATE$;
    }

    /**
     * Always returns 'false' since this state machine can never become final.
     *
     * @see IStatemachine#isFinal()
     */
    public boolean isFinal() {
        return false;
    }

    private void swapInEvents() {
        current.iface.switchOn = switchOn;
        switchOn = false;
        current.iface.switchOff = switchOff;
        switchOff = false;
        current.iface.attention = attention;
        attention = false;
        current.iface.block = block;
        block = false;
        current.iface.release = release;
        release = false;
        current.timeEvents.___TrafficLight_main_On_main_Released_time_event_0 = timeEvents[0];
        timeEvents[0] = false;
        current.timeEvents.___TrafficLight_main_On_main_Attention_time_event_0 = timeEvents[1];
        timeEvents[1] = false;
        current.timeEvents.___TrafficLight_main_On_main_PrepareBlock_time_event_0 = timeEvents[2];
        timeEvents[2] = false;
    }

    private void clearInEvents() {
        switchOn = false;
        switchOff = false;
        attention = false;
        block = false;
        release = false;
        timeEvents[0] = false;
        timeEvents[1] = false;
        timeEvents[2] = false;
    }

    private void microStep() {
        switch(stateVector[0]) {
            case MAIN_OFF:
                main_Off_react(-1l);
                break;
            case MAIN_ON_MAIN_BLOCKED:
                main_On_main_Blocked_react(-1l);
                break;
            case MAIN_ON_MAIN_RELEASED:
                main_On_main_Released_react(-1l);
                break;
            case MAIN_ON_MAIN_ATTENTION:
                main_On_main_Attention_react(-1l);
                break;
            case MAIN_ON_MAIN_PREPAREBLOCK:
                main_On_main_PrepareBlock_react(-1l);
                break;
            default:
                break;
        }
    }

    /**
     * Returns true if the given state is currently active otherwise false.
     */
    public boolean isStateActive(State state) {
        switch(state) {
            case MAIN_OFF:
                return stateVector[0] == State.MAIN_OFF;
            case MAIN_ON:
                return stateVector[0].ordinal() >= State.MAIN_ON.ordinal() && stateVector[0].ordinal() <= State.MAIN_ON_MAIN_PREPAREBLOCK.ordinal();
            case MAIN_ON_MAIN_BLOCKED:
                return stateVector[0] == State.MAIN_ON_MAIN_BLOCKED;
            case MAIN_ON_MAIN_RELEASED:
                return stateVector[0] == State.MAIN_ON_MAIN_RELEASED;
            case MAIN_ON_MAIN_ATTENTION:
                return stateVector[0] == State.MAIN_ON_MAIN_ATTENTION;
            case MAIN_ON_MAIN_PREPAREBLOCK:
                return stateVector[0] == State.MAIN_ON_MAIN_PREPAREBLOCK;
            default:
                return false;
        }
    }

    public void setTimerService(ITimerService timerService) {
        this.timerService = timerService;
    }

    private ITimerService getTimerService() {
        return timerService;
    }

    public void raiseTimeEvent(int eventID) {
        timeEvents[eventID] = true;
    }

    public Lights lights() {
        return lights;
    }

    public Config config() {
        return config;
    }

    private boolean switchOn;

    public void raiseSwitchOn() {
        switchOn = true;
    }

    private boolean switchOff;

    public void raiseSwitchOff() {
        switchOff = true;
    }

    private boolean attention;

    public void raiseAttention() {
        attention = true;
    }

    private boolean block;

    public void raiseBlock() {
        block = true;
    }

    private boolean release;

    public void raiseRelease() {
        release = true;
    }

    private boolean blocked;

    private void raiseBlocked() {
        blocked = true;
        blockedObservable.next(null);
    }

    private Observable<Void> blockedObservable = new Observable<Void>();

    private Observable<Void> getBlocked() {
        return blockedObservable;
    }

    private boolean released;

    private void raiseReleased() {
        released = true;
        releasedObservable.next(null);
    }

    private Observable<Void> releasedObservable = new Observable<Void>();

    private Observable<Void> getReleased() {
        return releasedObservable;
    }

    /* Entry action for state 'Off'. */
    private void entryAction_main_Off() {
        /* Entry action for state 'Off'. */
        lights.setRed(oFF);
        lights.setGreen(oFF);
        lights.setYellow(oFF);
    }

    /* Entry action for state 'Blocked'. */
    private void entryAction_main_On_main_Blocked() {
        /* Entry action for state 'Blocked'. */
        lights.setRed(oN);
        raiseBlocked();
    }

    /* Entry action for state 'Released'. */
    private void entryAction_main_On_main_Released() {
        /* Entry action for state 'Released'. */
        timerService.setTimer(this, 0, (config.getReleasePeriod() * 1000l), false);
        lights.setGreen(oN);
        raiseReleased();
    }

    /* Entry action for state 'Attention'. */
    private void entryAction_main_On_main_Attention() {
        /* Entry action for state 'Attention'. */
        timerService.setTimer(this, 1, 500l, true);
        lights.setYellow(oN);
    }

    /* Entry action for state 'PrepareBlock'. */
    private void entryAction_main_On_main_PrepareBlock() {
        /* Entry action for state 'PrepareBlock'. */
        timerService.setTimer(this, 2, (config.getPreparePeriod() * 1000l), false);
        lights.setYellow(oN);
    }

    /* Exit action for state 'Blocked'. */
    private void exitAction_main_On_main_Blocked() {
        /* Exit action for state 'Blocked'. */
        lights.setRed(oFF);
    }

    /* Exit action for state 'Released'. */
    private void exitAction_main_On_main_Released() {
        /* Exit action for state 'Released'. */
        timerService.unsetTimer(this, 0);
        lights.setGreen(oFF);
    }

    /* Exit action for state 'Attention'. */
    private void exitAction_main_On_main_Attention() {
        /* Exit action for state 'Attention'. */
        timerService.unsetTimer(this, 1);
        lights.setYellow(oFF);
    }

    /* Exit action for state 'PrepareBlock'. */
    private void exitAction_main_On_main_PrepareBlock() {
        /* Exit action for state 'PrepareBlock'. */
        timerService.unsetTimer(this, 2);
        lights.setYellow(oFF);
    }

    /* 'default' enter sequence for state Off */
    private void enterSequence_main_Off_default() {
        /* 'default' enter sequence for state Off */
        entryAction_main_Off();
        stateVector[0] = State.MAIN_OFF;
    }

    /* 'default' enter sequence for state On */
    private void enterSequence_main_On_default() {
        /* 'default' enter sequence for state On */
        enterSequence_main_On_main_default();
    }

    /* 'default' enter sequence for state Blocked */
    private void enterSequence_main_On_main_Blocked_default() {
        /* 'default' enter sequence for state Blocked */
        entryAction_main_On_main_Blocked();
        stateVector[0] = State.MAIN_ON_MAIN_BLOCKED;
    }

    /* 'default' enter sequence for state Released */
    private void enterSequence_main_On_main_Released_default() {
        /* 'default' enter sequence for state Released */
        entryAction_main_On_main_Released();
        stateVector[0] = State.MAIN_ON_MAIN_RELEASED;
    }

    /* 'default' enter sequence for state Attention */
    private void enterSequence_main_On_main_Attention_default() {
        /* 'default' enter sequence for state Attention */
        entryAction_main_On_main_Attention();
        stateVector[0] = State.MAIN_ON_MAIN_ATTENTION;
    }

    /* 'default' enter sequence for state PrepareBlock */
    private void enterSequence_main_On_main_PrepareBlock_default() {
        /* 'default' enter sequence for state PrepareBlock */
        entryAction_main_On_main_PrepareBlock();
        stateVector[0] = State.MAIN_ON_MAIN_PREPAREBLOCK;
    }

    /* 'default' enter sequence for region main */
    private void enterSequence_main_default() {
        /* 'default' enter sequence for region main */
        react_main__entry_Default();
    }

    /* 'default' enter sequence for region main */
    private void enterSequence_main_On_main_default() {
        /* 'default' enter sequence for region main */
        react_main_On_main__entry_Default();
    }

    /* Default exit sequence for state Off */
    private void exitSequence_main_Off() {
        /* Default exit sequence for state Off */
        stateVector[0] = State.$NULLSTATE$;
    }

    /* Default exit sequence for state On */
    private void exitSequence_main_On() {
        /* Default exit sequence for state On */
        exitSequence_main_On_main();
    }

    /* Default exit sequence for state Blocked */
    private void exitSequence_main_On_main_Blocked() {
        /* Default exit sequence for state Blocked */
        stateVector[0] = State.$NULLSTATE$;
        exitAction_main_On_main_Blocked();
    }

    /* Default exit sequence for state Released */
    private void exitSequence_main_On_main_Released() {
        /* Default exit sequence for state Released */
        stateVector[0] = State.$NULLSTATE$;
        exitAction_main_On_main_Released();
    }

    /* Default exit sequence for state Attention */
    private void exitSequence_main_On_main_Attention() {
        /* Default exit sequence for state Attention */
        stateVector[0] = State.$NULLSTATE$;
        exitAction_main_On_main_Attention();
    }

    /* Default exit sequence for state PrepareBlock */
    private void exitSequence_main_On_main_PrepareBlock() {
        /* Default exit sequence for state PrepareBlock */
        stateVector[0] = State.$NULLSTATE$;
        exitAction_main_On_main_PrepareBlock();
    }

    /* Default exit sequence for region main */
    private void exitSequence_main() {
        /* Default exit sequence for region main */
        switch(stateVector[0]) {
            case MAIN_OFF:
                exitSequence_main_Off();
                break;
            case MAIN_ON_MAIN_BLOCKED:
                exitSequence_main_On_main_Blocked();
                break;
            case MAIN_ON_MAIN_RELEASED:
                exitSequence_main_On_main_Released();
                break;
            case MAIN_ON_MAIN_ATTENTION:
                exitSequence_main_On_main_Attention();
                break;
            case MAIN_ON_MAIN_PREPAREBLOCK:
                exitSequence_main_On_main_PrepareBlock();
                break;
            default:
                break;
        }
    }

    /* Default exit sequence for region main */
    private void exitSequence_main_On_main() {
        /* Default exit sequence for region main */
        switch(stateVector[0]) {
            case MAIN_ON_MAIN_BLOCKED:
                exitSequence_main_On_main_Blocked();
                break;
            case MAIN_ON_MAIN_RELEASED:
                exitSequence_main_On_main_Released();
                break;
            case MAIN_ON_MAIN_ATTENTION:
                exitSequence_main_On_main_Attention();
                break;
            case MAIN_ON_MAIN_PREPAREBLOCK:
                exitSequence_main_On_main_PrepareBlock();
                break;
            default:
                break;
        }
    }

    /* Default react sequence for initial entry  */
    private void react_main__entry_Default() {
        /* Default react sequence for initial entry  */
        enterSequence_main_Off_default();
    }

    /* Default react sequence for initial entry  */
    private void react_main_On_main__entry_Default() {
        /* Default react sequence for initial entry  */
        enterSequence_main_On_main_Attention_default();
    }

    private long react(long transitioned_before) {
        /* State machine reactions. */
        return transitioned_before;
    }

    private long main_Off_react(long transitioned_before) {
        /* The reactions of state Off. */
        long transitioned_after = transitioned_before;
        if (transitioned_after < 0l) {
            if (current.iface.switchOn) {
                exitSequence_main_Off();
                enterSequence_main_On_default();
                react(0l);
                transitioned_after = 0l;
            }
        }
        /* If no transition was taken */
        if (transitioned_after == transitioned_before) {
            /* then execute local reactions. */
            transitioned_after = react(transitioned_before);
        }
        return transitioned_after;
    }

    private long main_On_react(long transitioned_before) {
        /* The reactions of state On. */
        long transitioned_after = transitioned_before;
        if (transitioned_after < 0l) {
            if (current.iface.switchOff) {
                exitSequence_main_On();
                enterSequence_main_Off_default();
                react(0l);
                transitioned_after = 0l;
            }
        }
        /* If no transition was taken */
        if (transitioned_after == transitioned_before) {
            /* then execute local reactions. */
            transitioned_after = react(transitioned_before);
        }
        return transitioned_after;
    }

    private long main_On_main_Blocked_react(long transitioned_before) {
        /* The reactions of state Blocked. */
        long transitioned_after = transitioned_before;
        if (transitioned_after < 0l) {
            if (current.iface.release) {
                exitSequence_main_On_main_Blocked();
                enterSequence_main_On_main_Released_default();
                main_On_react(0l);
                transitioned_after = 0l;
            } else {
                if (current.iface.attention) {
                    exitSequence_main_On_main_Blocked();
                    enterSequence_main_On_main_Attention_default();
                    main_On_react(0l);
                    transitioned_after = 0l;
                }
            }
        }
        /* If no transition was taken */
        if (transitioned_after == transitioned_before) {
            /* then execute local reactions. */
            transitioned_after = main_On_react(transitioned_before);
        }
        return transitioned_after;
    }

    private long main_On_main_Released_react(long transitioned_before) {
        /* The reactions of state Released. */
        long transitioned_after = transitioned_before;
        if (transitioned_after < 0l) {
            if (current.timeEvents.___TrafficLight_main_On_main_Released_time_event_0) {
                exitSequence_main_On_main_Released();
                current.timeEvents.___TrafficLight_main_On_main_Released_time_event_0 = false;
                enterSequence_main_On_main_PrepareBlock_default();
                main_On_react(0l);
                transitioned_after = 0l;
            }
        }
        /* If no transition was taken */
        if (transitioned_after == transitioned_before) {
            /* then execute local reactions. */
            transitioned_after = main_On_react(transitioned_before);
        }
        return transitioned_after;
    }

    private long main_On_main_Attention_react(long transitioned_before) {
        /* The reactions of state Attention. */
        long transitioned_after = transitioned_before;
        if (transitioned_after < 0l) {
            if (current.iface.block) {
                exitSequence_main_On_main_Attention();
                enterSequence_main_On_main_Blocked_default();
                main_On_react(0l);
                transitioned_after = 0l;
            }
        }
        /* If no transition was taken */
        if (transitioned_after == transitioned_before) {
            /* then execute local reactions. */
            if (current.timeEvents.___TrafficLight_main_On_main_Attention_time_event_0) {
                lights.setYellow(!(lights.yellow));
            }
            transitioned_after = main_On_react(transitioned_before);
        }
        return transitioned_after;
    }

    private long main_On_main_PrepareBlock_react(long transitioned_before) {
        /* The reactions of state PrepareBlock. */
        long transitioned_after = transitioned_before;
        if (transitioned_after < 0l) {
            if (current.timeEvents.___TrafficLight_main_On_main_PrepareBlock_time_event_0) {
                exitSequence_main_On_main_PrepareBlock();
                current.timeEvents.___TrafficLight_main_On_main_PrepareBlock_time_event_0 = false;
                enterSequence_main_On_main_Blocked_default();
                main_On_react(0l);
                transitioned_after = 0l;
            }
        }
        /* If no transition was taken */
        if (transitioned_after == transitioned_before) {
            /* then execute local reactions. */
            transitioned_after = main_On_react(transitioned_before);
        }
        return transitioned_after;
    }
}
