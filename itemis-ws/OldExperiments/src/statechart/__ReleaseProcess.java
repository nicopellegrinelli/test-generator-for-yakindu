/* Generated by itemis CREATE code generator. */
package statechart;

import com.yakindu.core.ICycleBased;
import com.yakindu.core.IStatemachine;
import com.yakindu.core.ITimed;
import com.yakindu.core.ITimerService;
import com.yakindu.core.rx.Observable;
import com.yakindu.core.rx.Observer;
import statechart.___TrafficLight;

public class __ReleaseProcess implements ITimed, ICycleBased {
	private static class TimeEventsEvBuf {
		private boolean __ReleaseProcess_process_Safe_time_event_0;
	}
	private static class ShadowEvBuf {
		private boolean trafficLight_released;
		private boolean trafficLight_blocked;
	}
	private static class __ReleaseProcessEvBuf {
		private TimeEventsEvBuf timeEvents = new TimeEventsEvBuf();
		private ShadowEvBuf shadow = new ShadowEvBuf();
	}
	public enum State {
		PROCESS_SAFE,
		PROCESS_START_RELEASE,
		PROCESS_RELEASED,
		PROCESS__FINAL_,
		$NULLSTATE$
	};
	
	private final State[] stateVector = new State[1];
	
	private ITimerService timerService;
	
	private final boolean[] timeEvents = new boolean[1];
	
	private boolean trafficLight_released;
	private boolean trafficLight_blocked;
	private __ReleaseProcessEvBuf current = new __ReleaseProcessEvBuf();
	
	private boolean isExecuting;
	
	protected boolean getIsExecuting() {
		return isExecuting;
	}
	
	protected void setIsExecuting(boolean value) {
		this.isExecuting = value;
	}
	public __ReleaseProcess() {
		for (int i = 0; i < 1; i++) {
			stateVector[i] = State.$NULLSTATE$;
		}
		
		clearInEvents();
		
		/* Default init sequence for statechart __ReleaseProcess */
		setTrafficLight(null);
		setSafePeriod(10l);
		
		isExecuting = false;
	}
	
	public void runCycle() {
		/* Performs a 'run to completion' step. */
		if (timerService == null) {
			throw new IllegalStateException("Timer service must be set.");
		}
		
		if (getIsExecuting()) {
			return;
		}
		isExecuting = true;
		swapInEvents();
		microStep();
		isExecuting = false;
	}
	
	public void enter() {
		/* Activates the state machine. */
		if (timerService == null) {
			throw new IllegalStateException("Timer service must be set.");
		}
		
		if (getIsExecuting()) {
			return;
		}
		isExecuting = true;
		/* Default enter sequence for statechart __ReleaseProcess */
		enterSequence_process_default();
		isExecuting = false;
	}
	
	public void exit() {
		/* Deactivates the state machine. */
		if (getIsExecuting()) {
			return;
		}
		isExecuting = true;
		/* Default exit sequence for statechart __ReleaseProcess */
		exitSequence_process();
		stateVector[0] = State.$NULLSTATE$;
		isExecuting = false;
	}
	
	/**
	 * @see IStatemachine#isActive()
	 */
	public boolean isActive() {
		return stateVector[0] != State.$NULLSTATE$;
	}
	
	/** 
	* @see IStatemachine#isFinal()
	*/
	public boolean isFinal() {
		return (stateVector[0] == State.PROCESS__FINAL_);
	}
	private void swapInEvents() {
		current.timeEvents.__ReleaseProcess_process_Safe_time_event_0 = timeEvents[0];
		timeEvents[0] = false;
		current.shadow.trafficLight_released = trafficLight_released;
		trafficLight_released = false;
		current.shadow.trafficLight_blocked = trafficLight_blocked;
		trafficLight_blocked = false;
	}
	
	private void clearInEvents() {
		trafficLight_released = false;
		trafficLight_blocked = false;
		timeEvents[0] = false;
	}
	
	private void microStep() {
		switch (stateVector[0]) {
		case PROCESS_SAFE:
			process_Safe_react(-1l);
			break;
		case PROCESS_START_RELEASE:
			process_Start_Release_react(-1l);
			break;
		case PROCESS_RELEASED:
			process_Released_react(-1l);
			break;
		case PROCESS__FINAL_:
			break;
		default:
			break;
		}
	}
	
	/**
	* Returns true if the given state is currently active otherwise false.
	*/
	public boolean isStateActive(State state) {
	
		switch (state) {
		case PROCESS_SAFE:
			return stateVector[0] == State.PROCESS_SAFE;
		case PROCESS_START_RELEASE:
			return stateVector[0] == State.PROCESS_START_RELEASE;
		case PROCESS_RELEASED:
			return stateVector[0] == State.PROCESS_RELEASED;
		case PROCESS__FINAL_:
			return stateVector[0] == State.PROCESS__FINAL_;
		default:
			return false;
		}
	}
	
	public void setTimerService(ITimerService timerService) {
		this.timerService = timerService;
	}
	
	public ITimerService getTimerService() {
		return timerService;
	}
	
	public void raiseTimeEvent(int eventID) {
		timeEvents[eventID] = true;
	}
	
	
	protected void raiseTrafficLight_released() {
		trafficLight_released = true;
	}
	
	protected void raiseTrafficLight_blocked() {
		trafficLight_blocked = true;
	}
	
	private boolean finished;
	
	
	protected void raiseFinished() {
		finished = true;
		finishedObservable.next(null);
	}
	
	private Observable<Void> finishedObservable = new Observable<Void>();
	
	public Observable<Void> getFinished() {
		return finishedObservable;
	}
	
	private ___TrafficLight trafficLight;
	
	private Observer<Void> trafficLight_released_observer = new Observer<Void>() {
		@Override
		public void next(Void value) {
			raiseTrafficLight_released();
		}
	};
	
	private Observer<Void> trafficLight_blocked_observer = new Observer<Void>() {
		@Override
		public void next(Void value) {
			raiseTrafficLight_blocked();
		}
	};
	
	
	public ___TrafficLight getTrafficLight() {
		return trafficLight;
	}
	
	public void setTrafficLight(___TrafficLight value) {
		if (this.trafficLight != null) {
			this.trafficLight.getReleased().unsubscribe(trafficLight_released_observer);
			this.trafficLight.getBlocked().unsubscribe(trafficLight_blocked_observer);
		}
		
		this.trafficLight = value;
		
		if (this.trafficLight != null) {
			this.trafficLight.getReleased().subscribe(trafficLight_released_observer);
			this.trafficLight.getBlocked().subscribe(trafficLight_blocked_observer);
		}
	}
	
	private long safePeriod;
	
	public long getSafePeriod() {
		return safePeriod;
	}
	
	public void setSafePeriod(long value) {
		this.safePeriod = value;
	}
	
	/* Entry action for state 'Safe'. */
	private void entryAction_process_Safe() {
		/* Entry action for state 'Safe'. */
		timerService.setTimer(this, 0, (getSafePeriod() * 1000l), false);
		getTrafficLight().raiseBlock();
	}
	
	/* Entry action for state 'Start Release'. */
	private void entryAction_process_Start_Release() {
		/* Entry action for state 'Start Release'. */
		getTrafficLight().raiseRelease();
	}
	
	/* Exit action for state 'Safe'. */
	private void exitAction_process_Safe() {
		/* Exit action for state 'Safe'. */
		timerService.unsetTimer(this, 0);
	}
	
	/* 'default' enter sequence for state Safe */
	private void enterSequence_process_Safe_default() {
		/* 'default' enter sequence for state Safe */
		entryAction_process_Safe();
		stateVector[0] = State.PROCESS_SAFE;
	}
	
	/* 'default' enter sequence for state Start Release */
	private void enterSequence_process_Start_Release_default() {
		/* 'default' enter sequence for state Start Release */
		entryAction_process_Start_Release();
		stateVector[0] = State.PROCESS_START_RELEASE;
	}
	
	/* 'default' enter sequence for state Released */
	private void enterSequence_process_Released_default() {
		/* 'default' enter sequence for state Released */
		stateVector[0] = State.PROCESS_RELEASED;
	}
	
	/* Default enter sequence for final state */
	private void enterSequence_process__final__default() {
		/* Default enter sequence for final state */
		stateVector[0] = State.PROCESS__FINAL_;
	}
	
	/* 'default' enter sequence for region process */
	private void enterSequence_process_default() {
		/* 'default' enter sequence for region process */
		react_process__entry_Default();
	}
	
	/* Default exit sequence for state Safe */
	private void exitSequence_process_Safe() {
		/* Default exit sequence for state Safe */
		stateVector[0] = State.$NULLSTATE$;
		exitAction_process_Safe();
	}
	
	/* Default exit sequence for state Start Release */
	private void exitSequence_process_Start_Release() {
		/* Default exit sequence for state Start Release */
		stateVector[0] = State.$NULLSTATE$;
	}
	
	/* Default exit sequence for final state. */
	private void exitSequence_process__final_() {
		/* Default exit sequence for final state. */
		stateVector[0] = State.$NULLSTATE$;
	}
	
	/* Default exit sequence for region process */
	private void exitSequence_process() {
		/* Default exit sequence for region process */
		switch (stateVector[0]) {
		case PROCESS_SAFE:
			exitSequence_process_Safe();
			break;
		case PROCESS_START_RELEASE:
			exitSequence_process_Start_Release();
			break;
		case PROCESS__FINAL_:
			exitSequence_process__final_();
			break;
		default:
			break;
		}
	}
	
	/* Default react sequence for initial entry  */
	private void react_process__entry_Default() {
		/* Default react sequence for initial entry  */
		enterSequence_process_Safe_default();
	}
	
	private long process_Safe_react(long transitioned_before) {
		/* The reactions of state Safe. */
		long transitioned_after = transitioned_before;
		if (transitioned_after<0l) {
			if (current.timeEvents.__ReleaseProcess_process_Safe_time_event_0) {
				exitSequence_process_Safe();
				current.timeEvents.__ReleaseProcess_process_Safe_time_event_0 = false;
				enterSequence_process_Start_Release_default();
				transitioned_after = 0l;
			}
		}
		/* If no transition was taken */
		if (transitioned_after==transitioned_before) {
			/* then execute local reactions. */
			transitioned_after = transitioned_before;
		}
		return transitioned_after;
	}
	
	private long process_Start_Release_react(long transitioned_before) {
		/* The reactions of state Start Release. */
		long transitioned_after = transitioned_before;
		if (transitioned_after<0l) {
			if (current.shadow.trafficLight_released) {
				exitSequence_process_Start_Release();
				enterSequence_process_Released_default();
				transitioned_after = 0l;
			}
		}
		/* If no transition was taken */
		if (transitioned_after==transitioned_before) {
			/* then execute local reactions. */
			transitioned_after = transitioned_before;
		}
		return transitioned_after;
	}
	
	private long process_Released_react(long transitioned_before) {
		/* The reactions of state Released. */
		long transitioned_after = transitioned_before;
		if (transitioned_after<0l) {
			if (current.shadow.trafficLight_blocked) {
				enterSequence_process__final__default();
				transitioned_after = 0l;
			}
		}
		/* If no transition was taken */
		if (transitioned_after==transitioned_before) {
			/* then execute local reactions. */
			transitioned_after = transitioned_before;
		}
		return transitioned_after;
	}
	
}
